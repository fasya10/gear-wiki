"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[7532],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),d=r,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||i;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2118:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:12},o="Supply chain",s={unversionedId:"examples/supply-chain",id:"examples/supply-chain",title:"Supply chain",description:"In logistics, a supply chain is a system for tracking and delivering to an end consumer various items. As a rule, such systems can't work without a lot of paperwork and other layers of bureaucracy. All of this costs a lot of time and money and increases the likelihood of an accidental error or, worst of all, a fraud. With the help of smart contract and blockchain technologies, it is possible to eliminate these problems by making a supply chain more efficient, reliable and transparent.",source:"@site/docs/examples/supply-chain.md",sourceDirName:"examples",slug:"/examples/supply-chain",permalink:"/docs/examples/supply-chain",draft:!1,editUrl:"https://github.com/gear-tech/wiki/edit/master/docs/examples/supply-chain.md",tags:[],version:"current",sidebarPosition:12,frontMatter:{sidebar_position:12},sidebar:"docs",previous:{title:"Dutch Auction",permalink:"/docs/examples/dutch-auction"},next:{title:"Multisig Wallet",permalink:"/docs/examples/multisig-wallet"}},l={},c=[{value:"How to run",id:"how-to-run",level:2},{value:"\u2692\ufe0f Build programs",id:"\ufe0f-build-programs",level:3},{value:"\ud83c\udfd7\ufe0f Upload programs",id:"\ufe0f-upload-programs",level:3},{value:"\ud83d\udda5\ufe0f Run UI",id:"\ufe0f-run-ui",level:3},{value:"Logic",id:"logic",level:2},{value:"Item route",id:"item-route",level:3},{value:"Interface",id:"interface",level:2},{value:"Initialization",id:"initialization",level:3},{value:"Actions",id:"actions",level:3},{value:"Program metadata and state",id:"program-metadata-and-state",level:3},{value:"Source code",id:"source-code",level:2}],p={toc:c},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"supply-chain"},"Supply chain"),(0,r.kt)("p",null,"In logistics, a supply chain is a system for tracking and delivering to an end consumer various items. As a rule, such systems can't work without a lot of paperwork and other layers of bureaucracy. All of this costs a lot of time and money and increases the likelihood of an accidental error or, worst of all, a fraud. With the help of smart contract and blockchain technologies, it is possible to eliminate these problems by making a supply chain more efficient, reliable and transparent."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/gear-dapps/supply-chain"},"Supply chain contract"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/gear-dapps/supply-chain/tree/master/frontend"},"Supply chain UI"),".")),(0,r.kt)("h2",{id:"how-to-run"},"How to run"),(0,r.kt)("h3",{id:"\ufe0f-build-programs"},"\u2692\ufe0f Build programs"),(0,r.kt)("p",null,"Upload Supply chain contract requires build two auxiliary contracts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Build ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/gear-dapps/non-fungible-token/"},"NFT contract")," as described in ",(0,r.kt)("inlineCode",{parentName:"li"},"README.md")),(0,r.kt)("li",{parentName:"ul"},"Build ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/gear-dapps/sharded-fungible-token/"},"Sharded FT contract")," as described in ",(0,r.kt)("inlineCode",{parentName:"li"},"README.md")),(0,r.kt)("li",{parentName:"ul"},"Build ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/gear-dapps/supply-chain"},"Supply Chain contract")," as described in ",(0,r.kt)("inlineCode",{parentName:"li"},"README.md"))),(0,r.kt)("h3",{id:"\ufe0f-upload-programs"},"\ud83c\udfd7\ufe0f Upload programs"),(0,r.kt)("p",null,"You can deploy a program using ",(0,r.kt)("a",{parentName:"p",href:"https://idea.gear-tech.io/"},"idea.gear-tech.io"),". In the network selector choose ",(0,r.kt)("inlineCode",{parentName:"p"},"Staging Testnet")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Development")," (in this case, you should have a local node running)."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"}," Non-Fungible Token "))),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Upload program ",(0,r.kt)("inlineCode",{parentName:"li"},"nft.opt.wasm")," from ",(0,r.kt)("inlineCode",{parentName:"li"},"/target/wasm32-unknown-unknown/release/")),(0,r.kt)("li",{parentName:"ol"},"Upload metadata file ",(0,r.kt)("inlineCode",{parentName:"li"},"meta.txt")),(0,r.kt)("li",{parentName:"ol"},"Specify ",(0,r.kt)("inlineCode",{parentName:"li"},"init payload")," and calculate gas!")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Init payload:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"name ",(0,r.kt)("inlineCode",{parentName:"li"},"Str")," - NFT collection name"),(0,r.kt)("li",{parentName:"ul"},"symbol ",(0,r.kt)("inlineCode",{parentName:"li"},"Str")," - NFT collection symbol"),(0,r.kt)("li",{parentName:"ul"},"base_uri ",(0,r.kt)("inlineCode",{parentName:"li"},"Str")," - NFT collection base URI"),(0,r.kt)("li",{parentName:"ul"},"royalties ",(0,r.kt)("inlineCode",{parentName:"li"},"Option<Royalties>")," - Optional param to specify accounts to pay royalties"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"}," Sharded Fungible Token "))),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Upload code ",(0,r.kt)("inlineCode",{parentName:"li"},"ft_logic.opt.wasm")," from ",(0,r.kt)("inlineCode",{parentName:"li"},"/target/wasm32-unknown-unknown/release/")),(0,r.kt)("li",{parentName:"ol"},"Upload code ",(0,r.kt)("inlineCode",{parentName:"li"},"ft_storage.opt.wasm")," from ",(0,r.kt)("inlineCode",{parentName:"li"},"/target/wasm32-unknown-unknown/release/")),(0,r.kt)("li",{parentName:"ol"},"Upload program ",(0,r.kt)("inlineCode",{parentName:"li"},"ft_main.opt.wasm")," from ",(0,r.kt)("inlineCode",{parentName:"li"},"/target/wasm32-unknown-unknown/release/")),(0,r.kt)("li",{parentName:"ol"},"Upload metadata file ",(0,r.kt)("inlineCode",{parentName:"li"},"meta.txt")),(0,r.kt)("li",{parentName:"ol"},"Specify ",(0,r.kt)("inlineCode",{parentName:"li"},"init payload")," and calculate gas!")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"InitFToken payload:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"storage_code_hash (H256) - storage code ID"),(0,r.kt)("li",{parentName:"ul"},"ft_logic_code_hash (H256) - logic code ID"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"}," Supply Chain "))),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Upload code ",(0,r.kt)("inlineCode",{parentName:"li"},"supply_chain.opt.wasm")," from ",(0,r.kt)("inlineCode",{parentName:"li"},"/target/wasm32-unknown-unknown/release/"))),(0,r.kt)("h3",{id:"\ufe0f-run-ui"},"\ud83d\udda5\ufe0f Run UI"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Install packages")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"yarn install\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Configure .evn file. Specify network address and program ID like in the example below:")),(0,r.kt)("p",null,"For proper application functioning, one needs to adjust an environment variable parameters. An example is available ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/supply-chain/blob/master/frontend/.env.example"},"here"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"REACT_APP_NODE_ADDRESS=wss://rpc-node.gear-tech.io\nREACT_APP_CODE_ADDRESS=0x7141c1f9eb7c48063fc7d3a00e7ef157c4a95a83d656efaee910104d429b0de9\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Run app")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"yarn start\n")),(0,r.kt)("h2",{id:"logic"},"Logic"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Each newly produced item gets the NFT (in Gear's context - ",(0,r.kt)("a",{parentName:"li",href:"/docs/examples/gnft-721"},"Gear non-fungible token (gNFT)")," and its ID equals an ID of the item. Then, as an item moves along a supply chain, an item's NFT transfers between a supply chain program, item's producer, and future distributor, retailer and end consumer."),(0,r.kt)("li",{parentName:"ul"},"Anyone who knows an item's ID can get item info."),(0,r.kt)("li",{parentName:"ul"},"Sale, purchase, delivery is made in ",(0,r.kt)("a",{parentName:"li",href:"/docs/examples/gft-20"},"Gear fungible tokens (gFT)"),".")),(0,r.kt)("p",null,"Item info has the following struct:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct ItemInfo {\n    /// Item\u2019s producer [`ActorId`].\n    pub producer: ActorId,\n    /// [`ActorId`] of an item\u2019s current or past distributor (depends on item\u2019s\n    /// `state`). If it equals [`ActorId::zero()`], then it means that an item\n    /// has never had a distributor.\n    pub distributor: ActorId,\n    /// [`ActorId`] of an item\u2019s current or past retailer (depends on item\u2019s\n    /// `state`). If it equals [`ActorId::zero()`], then it means that an item\n    /// has never had a retailer.\n    pub retailer: ActorId,\n\n    pub state: ItemState,\n    /// An item\u2019s price. If it equals 0, then, depending on item\u2019s `state`, an\n    /// item is sold for free or has never been put up for sale.\n    pub price: u128,\n    /// Milliseconds during which a current seller should deliver an item.\n    pub delivery_time: u64,\n}\n")),(0,r.kt)("p",null,"And ",(0,r.kt)("inlineCode",{parentName:"p"},"ItemState")," has the following struct and inner enums:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct ItemState {\n    pub state: ItemEventState,\n    pub by: Role,\n}\n\npub enum ItemEventState {\n    Produced,\n    Purchased,\n    Received,\n    Processed,\n    Packaged,\n    ForSale,\n    Approved,\n    Shipped,\n}\n\npub enum Role {\n    Producer,\n    Distributor,\n    Retailer,\n    Consumer,\n}\n")),(0,r.kt)("h3",{id:"item-route"},"Item route"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The item is produced with ",(0,r.kt)("inlineCode",{parentName:"li"},"ProducerAction::Produce"),"."),(0,r.kt)("li",{parentName:"ol"},"The item is put up for sale with ",(0,r.kt)("inlineCode",{parentName:"li"},"ProducerAction::PutUpForSale"),"."),(0,r.kt)("li",{parentName:"ol"},"The item is purchased with ",(0,r.kt)("inlineCode",{parentName:"li"},"DistributorAction::Purchase"),"."),(0,r.kt)("li",{parentName:"ol"},"The purchase is approved or not with ",(0,r.kt)("inlineCode",{parentName:"li"},"ProducerAction::Approve"),". In the latter case the item returns on the ",(0,r.kt)("strong",{parentName:"li"},"2")," step."),(0,r.kt)("li",{parentName:"ol"},"The item is shipped with ",(0,r.kt)("inlineCode",{parentName:"li"},"ProducerAction::Ship"),"."),(0,r.kt)("li",{parentName:"ol"},"The item is received with ",(0,r.kt)("inlineCode",{parentName:"li"},"DistributorAction::Receive"),"."),(0,r.kt)("li",{parentName:"ol"},"The item is processed with ",(0,r.kt)("inlineCode",{parentName:"li"},"DistributorAction::Process"),"."),(0,r.kt)("li",{parentName:"ol"},"The item is packaged with ",(0,r.kt)("inlineCode",{parentName:"li"},"DistributorAction::Package"),"."),(0,r.kt)("li",{parentName:"ol"},"The item is put up for sale with ",(0,r.kt)("inlineCode",{parentName:"li"},"DistributorAction::PutUpForSale"),"."),(0,r.kt)("li",{parentName:"ol"},"The item is purchased with ",(0,r.kt)("inlineCode",{parentName:"li"},"RetailerAction::Purchase"),"."),(0,r.kt)("li",{parentName:"ol"},"The purchase is approved or not with ",(0,r.kt)("inlineCode",{parentName:"li"},"DistributorAction::Approve"),". In the latter case the item returns on the ",(0,r.kt)("strong",{parentName:"li"},"9")," step."),(0,r.kt)("li",{parentName:"ol"},"The item is shipped with ",(0,r.kt)("inlineCode",{parentName:"li"},"DistributorAction::Ship"),"."),(0,r.kt)("li",{parentName:"ol"},"The item is received with ",(0,r.kt)("inlineCode",{parentName:"li"},"RetailerAction::Receive"),"."),(0,r.kt)("li",{parentName:"ol"},"The item is put up for sale with ",(0,r.kt)("inlineCode",{parentName:"li"},"RetailerAction::PutUpForSale"),"."),(0,r.kt)("li",{parentName:"ol"},"The item is purchased with ",(0,r.kt)("inlineCode",{parentName:"li"},"ConsumerAction::Purchase"),".")),(0,r.kt)("p",null,"The end!"),(0,r.kt)("h2",{id:"interface"},"Interface"),(0,r.kt)("h3",{id:"initialization"},"Initialization"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"/// Initializes the Supply chain contract.\n///\n/// # Requirements\n/// - Each [`ActorId`] of `producers`, `distributors`, and `retailers` mustn't\n/// equal [`ActorId::zero()`].\n#[derive(Encode, Decode, Hash, TypeInfo, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Clone)]\npub struct Initialize {\n    /// IDs of actors that'll have the right to interact with a supply chain on\n    /// behalf of a producer.\n    pub producers: Vec<ActorId>,\n    /// IDs of actors that'll have the right to interact with a supply chain on\n    /// behalf of a distributor.\n    pub distributors: Vec<ActorId>,\n    /// IDs of actors that'll have the right to interact with a supply chain on\n    /// behalf of a retailer.\n    pub retailers: Vec<ActorId>,\n\n    /// A FT contract [`ActorId`].\n    pub fungible_token: ActorId,\n    /// An NFT contract [`ActorId`].\n    pub non_fungible_token: ActorId,\n}\n")),(0,r.kt)("h3",{id:"actions"},"Actions"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"/// Sends the contract info about what it should do.\n#[derive(Encode, Decode, TypeInfo, Debug, PartialEq, Eq, PartialOrd, Ord, Clone)]\npub struct Action {\n    pub action: InnerAction,\n    pub kind: TransactionKind,\n}\n\n/// A part of [`Action`].\n///\n/// Determines how an action will be processed.\n///\n/// The contract has a transaction caching mechanism for a continuation of\n/// partially processed asynchronous actions. Most often, the reason of an\n/// underprocession is the lack of gas.\n///\n/// Important notes:\n/// - Only the last sent asynchronous action for\n/// [`msg::source()`](gstd::msg::source) is cached.\n/// - Non-asynchronous actions are never cached.\n/// - There's no guarantee every underprocessed asynchronous action will be\n/// cached. Use [`StateQuery::IsActionCached`] to check if some action is cached\n/// for some [`ActorId`].\n/// - It's possible to send a retry action with a different payload, and it'll\n/// continue with it because, for some action, not all payload is saved in the\n/// cache (see [`CachedAction`]).\n/// - The cache memory has a limit, so when it's reached every oldest cached\n/// action is replaced with a new one.\n#[derive(\n    Default, Encode, Decode, TypeInfo, Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Hash,\n)]\npub enum TransactionKind {\n    #[default]\n    New,\n    Retry,\n}\n\n/// A part of [`Action`].\n#[derive(Encode, Decode, TypeInfo, Debug, PartialEq, Eq, PartialOrd, Ord, Clone)]\npub enum InnerAction {\n    Producer(ProducerAction),\n    Distributor(DistributorAction),\n    Retailer(RetailerAction),\n    Consumer(ConsumerAction),\n}\n/// Actions for a producer.\n///\n/// Should be used inside [`InnerAction::Producer`].\n#[derive(Encode, Decode, TypeInfo, Debug, PartialEq, Eq, PartialOrd, Ord, Clone)]\npub enum ProducerAction {\n    /// Produces one item and a corresponding NFT with given `token_metadata`.\n    ///\n    /// Transfers the created NFT for the item to a producer\n    /// ([`msg::source()`]).\n    ///\n    /// # Requirements\n    /// - [`msg::source()`] must be a producer in a supply chain.\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Produced`] & [`Role::Producer`].\n    ///\n    /// [`msg::source()`]: gstd::msg::source\n    Produce { token_metadata: TokenMetadata },\n\n    /// Puts a produced item up for sale to distributors for given `price` on\n    /// behalf of a producer.\n    ///\n    /// Transfers an item's NFT to the Supply chain contract\n    /// ([`exec::program_id()`](gstd::exec::program_id)).\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the producer of the item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Produced`] &\n    /// [`Role::Producer`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::ForSale`] & [`Role::Producer`].\n    PutUpForSale { item_id: ItemId, price: u128 },\n\n    /// Approves or not a distributor's purchase on behalf of a producer.\n    ///\n    /// If the purchase is approved, then item's [`ItemEventState`] changes to\n    /// [`Approved`](ItemEventState::Approved) and, from that moment, an item\n    /// can be shipped (by [`ProducerAction::Ship`]).\n    ///\n    /// If the purchase is **not** approved, then fungible tokens for it are\n    /// refunded from the Supply chain contract\n    /// ([`exec::program_id()`](gstd::exec::program_id)) to the item's\n    /// distributor and item's [`ItemEventState`] changes back to\n    /// [`ForSale`](ItemEventState::ForSale).\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the producer of the item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Produced`] &\n    /// [`Role::Distributor`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Approved`]/[`ItemEventState::ForSale`] &\n    /// [`Role::Producer`].\n    Approve {\n        item_id: ItemId,\n        /// Yes ([`true`]) or no ([`false`]).\n        approve: bool,\n    },\n\n    /// Starts a shipping of a purchased item to a distributor on behalf of a\n    /// producer.\n    ///\n    /// Starts the countdown for the delivery time specified for the item in\n    /// [`DistributorAction::Purchase`].\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the producer of the item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Approved`] &\n    /// [`Role::Producer`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Shipped`] & [`Role::Producer`].\n    Ship(ItemId),\n}\n\n/// Actions for a distributor.\n///\n/// Should be used inside [`InnerAction::Distributor`].\n#[derive(Encode, Decode, TypeInfo, Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Hash)]\npub enum DistributorAction {\n    /// Purchases an item from a producer on behalf of a distributor.\n    ///\n    /// Transfers fungible tokens for purchasing the item to the Supply chain\n    /// contract ([`exec::program_id()`](gstd::exec::program_id)) until the item\n    /// is received (by [`DistributorAction::Receive`]).\n    ///\n    /// **Note:** the item's producer must approve or not this purchase by\n    /// [`ProducerAction::Approve`].\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be a distributor.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::ForSale`] &\n    /// [`Role::Producer`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Purchased`] & [`Role::Distributor`].\n    Purchase {\n        item_id: ItemId,\n        /// Milliseconds during which the producer of an item should deliver it.\n        /// A countdown starts after [`ProducerAction::Ship`] is executed.\n        delivery_time: u64,\n    },\n\n    /// Receives a shipped item from a producer on behalf of a distributor.\n    ///\n    /// Depending on the time spent on a delivery, transfers fungible tokens for\n    /// purchasing the item from the Supply chain contract\n    /// ([`exec::program_id()`](gstd::exec::program_id)) to the item's producer\n    /// or, as a penalty for being late, refunds a half or all of them to the\n    /// item's distributor ([`msg::source()`]).\n    ///\n    /// Transfers an item's NFT to the distributor ([`msg::source()`]).\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`] must be the distributor of the item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Shipped`] &\n    /// [`Role::Producer`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Received`] & [`Role::Distributor`].\n    ///\n    /// [`msg::source()`]: gstd::msg::source\n    Receive(ItemId),\n\n    /// Processes a received item on behalf of a distributor.\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the distributor of the\n    /// item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Received`] &\n    /// [`Role::Distributor`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Processed`] & [`Role::Distributor`].\n    Process(ItemId),\n\n    /// Packages a processed item on behalf of a distributor.\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the distributor of the\n    /// item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Processed`] &\n    /// [`Role::Distributor`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Packaged`] & [`Role::Distributor`].\n    Package(ItemId),\n\n    /// Puts a packaged item up for sale to retailers for given `price` on\n    /// behalf of a distributor.\n    ///\n    /// Transfers an item's NFT to the Supply chain contract\n    /// ([`exec::program_id()`](gstd::exec::program_id)).\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the distributor of the\n    /// item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Packaged`] &\n    /// [`Role::Distributor`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::ForSale`] & [`Role::Distributor`].\n    PutUpForSale { item_id: ItemId, price: u128 },\n\n    /// Approves or not a retailer's purchase on behalf of a distributor.\n    ///\n    /// If the purchase is approved, then item's [`ItemEventState`] changes to\n    /// [`Approved`](ItemEventState::Approved) and, from that moment, an item\n    /// can be shipped (by [`DistributorAction::Ship`]).\n    ///\n    /// If the purchase is **not** approved, then fungible tokens for it are\n    /// refunded from the Supply chain contract\n    /// ([`exec::program_id()`](gstd::exec::program_id)) to the item's retailer\n    /// and item's [`ItemEventState`] changes back to\n    /// [`ForSale`](ItemEventState::ForSale).\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the distributor of the\n    /// item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Purchased`] &\n    /// [`Role::Retailer`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Approved`]/[`ItemEventState::ForSale`] &\n    /// [`Role::Distributor`].\n    Approve {\n        item_id: ItemId,\n        /// Yes ([`true`]) or no ([`false`]).\n        approve: bool,\n    },\n\n    /// Starts a shipping of a purchased item to a retailer on behalf of a\n    /// distributor.\n    ///\n    /// Starts the countdown for the delivery time specified for the item in\n    /// [`RetailerAction::Purchase`].\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the distributor of the\n    /// item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Approved`] &\n    /// [`Role::Distributor`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Shipped`] & [`Role::Distributor`].\n    Ship(ItemId),\n}\n\n/// Actions for a retailer.\n///\n/// Should be used inside [`InnerAction::Retailer`].\n#[derive(Encode, Decode, TypeInfo, Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Hash)]\npub enum RetailerAction {\n    /// Purchases an item from a distributor on behalf of a retailer.\n    ///\n    /// Transfers fungible tokens for purchasing the item to the Supply chain\n    /// contract ([`exec::program_id()`](gstd::exec::program_id)) until the item\n    /// is received (by [`RetailerAction::Receive`]).\n    ///\n    /// **Note:** the item's distributor must approve or not this purchase by\n    /// [`DistributorAction::Approve`].\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be a retailer.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::ForSale`] &\n    /// [`Role::Distributor`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Purchased`] & [`Role::Retailer`].\n    Purchase {\n        item_id: ItemId,\n        /// Milliseconds during which the distributor of an item should deliver\n        /// it. A countdown starts after [`DistributorAction::Ship`] is\n        /// executed.\n        delivery_time: u64,\n    },\n\n    /// Receives a shipped item from a distributor on behalf of a retailer.\n    ///\n    /// Depending on the time spent on a delivery, transfers fungible tokens for\n    /// purchasing the item from the Supply chain contract\n    /// ([`exec::program_id()`](gstd::exec::program_id)) to the item's\n    /// distributor or, as a penalty for being late, refunds a half or all of\n    /// them to the item's retailer ([`msg::source()`]).\n    ///\n    /// Transfers an item's NFT to the retailer ([`msg::source()`]).\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`] must be the retailer of the item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Shipped`] &\n    /// [`Role::Distributor`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Received`] & [`Role::Retailer`].\n    ///\n    /// [`msg::source()`]: gstd::msg::source\n    Receive(ItemId),\n\n    /// Puts a received item up for sale to consumers for given `price` on\n    /// behalf of a retailer.\n    ///\n    /// Transfers an item's NFT to the Supply chain contract\n    /// ([`exec::program_id()`](gstd::exec::program_id)).\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - [`msg::source()`](gstd::msg::source) must be the retailer of the item.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::Received`] &\n    /// [`Role::Retailer`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::ForSale`] & [`Role::Retailer`].\n    PutUpForSale { item_id: ItemId, price: u128 },\n}\n\n/// Actions for a consumer.\n///\n/// Should be used inside [`InnerAction::Consumer`].\n#[derive(Encode, Decode, TypeInfo, Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Hash)]\npub enum ConsumerAction {\n    /// Purchases an item from a retailer.\n    ///\n    /// Transfers fungible tokens for purchasing the item to its retailer.\n    ///\n    /// Transfers an item's NFT to the consumer\n    /// ([`msg::source()`](gstd::msg::source)).\n    ///\n    /// # Requirements\n    /// - The item must exist in a supply chain.\n    /// - Item's [`ItemState`] must contain [`ItemEventState::ForSale`] &\n    /// [`Role::Retailer`].\n    ///\n    /// On success, replies with [`Event`] where [`ItemState`] contains\n    /// [`ItemEventState::Purchased`] & [`Role::Consumer`].\n    Purchase(ItemId),\n}\n")),(0,r.kt)("h3",{id:"program-metadata-and-state"},"Program metadata and state"),(0,r.kt)("p",null,"Metadata interface description:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct ContractMetadata;\n\nimpl Metadata for ContractMetadata {\n    type Init = InOut<Initialize, Result<(), Error>>;\n    type Handle = InOut<Action, Result<Event, Error>>;\n    type Reply = ();\n    type Others = ();\n    type Signal = ();\n    type State = State;\n}\n")),(0,r.kt)("p",null,"To display the full contract state information, the ",(0,r.kt)("inlineCode",{parentName:"p"},"state()")," function is used:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[no_mangle]\nextern "C" fn state() {\n    reply(common_state())\n        .expect("Failed to encode or reply with `<ContractMetadata as Metadata>::State` from `state()`");\n}\n')),(0,r.kt)("p",null,"To display only necessary certain values from the state, you need to write a separate crate. In this crate, specify functions that will return the desired values from the ",(0,r.kt)("inlineCode",{parentName:"p"},"State")," struct. For example - ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/supply-chain/tree/master/state"},"gear-dapps/supply-chain/state"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[metawasm]\npub trait Metawasm {\n    type State = <ContractMetadata as Metadata>::State;\n\n    fn item_info(item_id: ItemId, state: Self::State) -> Option<ItemInfo> {\n        state.item_info(item_id)\n    }\n\n    fn participants(state: Self::State) -> Participants {\n        state.participants()\n    }\n\n    fn roles(actor: ActorId, state: Self::State) -> Vec<Role> {\n        state.roles(actor)\n    }\n\n    fn existing_items(state: Self::State) -> Vec<(ItemId, ItemInfo)> {\n        state.items\n    }\n\n    fn fungible_token(state: Self::State) -> ActorId {\n        state.fungible_token\n    }\n\n    fn non_fungible_token(state: Self::State) -> ActorId {\n        state.non_fungible_token\n    }\n\n    fn is_action_cached(actor_action: ActorIdInnerSupplyChainAction, state: Self::State) -> bool {\n        let (actor, action) = actor_action;\n\n        state.is_action_cached(actor, action)\n    }\n}\n\npub type ActorIdInnerSupplyChainAction = (ActorId, InnerAction);\n")),(0,r.kt)("h2",{id:"source-code"},"Source code"),(0,r.kt)("p",null,"The source code of this example of a supply chain smart contract and an implementation of its testing is available on ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/supply-chain"},"GitHub"),". They can be used as is or modified to suit your own scenarios."),(0,r.kt)("p",null,"For more details about testing smart contracts written on Gear, refer to the ",(0,r.kt)("a",{parentName:"p",href:"/docs/developing-contracts/testing"},"Program Testing")," article."))}m.isMDXComponent=!0}}]);