"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[7517],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),h=r,u=d["".concat(l,".").concat(h)]||d[h]||m[h]||o;return n?a.createElement(u,i(i({ref:t},p),{},{components:n})):a.createElement(u,i({ref:t},p))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2046:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_label:"Introduction",sidebar_position:1},i="Attention developers!",s={unversionedId:"developing-contracts/introduction",id:"developing-contracts/introduction",title:"Attention developers!",description:"Want to take your blockchain development skills to the next level? Join Gear Academy's free course, \"Gear Smart Contract Developer.\" In this comprehensive course, you'll learn the ins and outs of developing on the Gear Protocol, from deploying programs onto the blockchain and interacting with them, to testing your programs on the Gear Network. You'll also gain hands-on experience navigating the @gear-js library for interacting with contracts on the client side and developing real-world applications, including contracts and frontends. Don't miss this opportunity to become a pro Gear blockchain developer. Enroll now in Gear Academy's \"Gear Smart Contract Developer\" course!",source:"@site/docs/developing-contracts/introduction.md",sourceDirName:"developing-contracts",slug:"/developing-contracts/introduction",permalink:"/docs/developing-contracts/introduction",draft:!1,editUrl:"https://github.com/gear-tech/wiki/edit/master/docs/developing-contracts/introduction.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_label:"Introduction",sidebar_position:1},sidebar:"docs",previous:{title:"Troubleshooting",permalink:"/docs/node/troubleshooting"},next:{title:"Gear Library",permalink:"/docs/developing-contracts/gstd"}},l={},c=[{value:"What is a Gear smart contract?",id:"what-is-a-gear-smart-contract",level:2},{value:"Predefined entry points (exported functions)",id:"predefined-entry-points-exported-functions",level:2},{value:"API functions (imported functions)",id:"api-functions-imported-functions",level:2},{value:"Basic stages of the Gear smart contract lifecycle",id:"basic-stages-of-the-gear-smart-contract-lifecycle",level:2},{value:"Smart contract key features",id:"smart-contract-key-features",level:2},{value:"State function",id:"state-function",level:3},{value:"Asynchronous programming",id:"asynchronous-programming",level:3},{value:"Creating programs from programs",id:"creating-programs-from-programs",level:3},{value:"Gas reservation",id:"gas-reservation",level:3},{value:"Delayed messages",id:"delayed-messages",level:3},{value:"System signals",id:"system-signals",level:3}],p={toc:c},d="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"attention-developers"},"Attention developers!"),(0,r.kt)("admonition",{type:"important"},(0,r.kt)("p",{parentName:"admonition"}," Want to take your blockchain development skills to the next level? Join ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"https://academy.gear.foundation/"},"Gear Academy's"))," free course, \"Gear Smart Contract Developer.\" In this comprehensive course, you'll learn the ins and outs of developing on the Gear Protocol, from deploying programs onto the blockchain and interacting with them, to testing your programs on the Gear Network. You'll also gain hands-on experience navigating the ",(0,r.kt)("inlineCode",{parentName:"p"},"@gear-js")," library for interacting with contracts on the client side and developing real-world applications, including contracts and frontends. Don't miss this opportunity to become a pro Gear blockchain developer. Enroll now in Gear Academy's ",(0,r.kt)("strong",{parentName:"p"},'"',(0,r.kt)("a",{parentName:"strong",href:"https://academy.gear.foundation/course/tamagotchi"},"Gear Smart Contract Developer"),'"')," course!")),(0,r.kt)("h2",{id:"what-is-a-gear-smart-contract"},"What is a Gear smart contract?"),(0,r.kt)("p",null,"Gear smart contract a just a program that runs on the Gear Protocol. It is a piece of code compiled to Wasm that is deployed to the blockchain and can be executed by anyone who sends a message to it. The program can store data, receive and send messages, and perform any other actions that are allowed by the Gear Protocol."),(0,r.kt)("p",null,"Every program should have a set of exported functions that can be called by the Gear Protocol. These functions are called entry points. The Gear Protocol has a set of predefined entry points that are used to initialize the program, handle incoming messages, and process replies to previously sent messages."),(0,r.kt)("p",null,"But we can't implement any business logic without using imported functions that form the API for the program. The Gear Protocol has a set of predefined API functions that can be used by any program. There are low-level functions that allow us to load incoming message's payload, send messages, and perform other actions. And there are higher-level libraries that allow us to interact with the Gear Protocol in a more convenient way."),(0,r.kt)("h2",{id:"predefined-entry-points-exported-functions"},"Predefined entry points (exported functions)"),(0,r.kt)("p",null,"The central exported function of the Gear smart contract is ",(0,r.kt)("inlineCode",{parentName:"p"},"handle()"),". It is called every time the program receives an incoming message. Below is the Rust example code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[no_mangle]\nextern "C" fn handle() {\n    // Execute this code during explicitly incoming message\n}\n')),(0,r.kt)("p",null,"This function is obligatory to be defined in the program."),(0,r.kt)("p",null,"In this function, we are to define the main business logic of our program. For example, we can check the incoming message and perform some actions depending on the message type. Also, we can send a message to another program. Finally, we can send a reply to the message that was received by the program."),(0,r.kt)("p",null,"As with any other program intended to be executed in some environment, Gear smart contract has its own lifecycle. It is initialized, receives messages, and can be terminated. We are to define the optional ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," function if we want to perform some actions during the initialization of the program. For example, we can store some data in the program's memory. The ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," function is called only once during the program initialization."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[no_mangle]\nextern "C" fn init() {\n    // Execute this code during contract initialization\n}\n')),(0,r.kt)("p",null,"If there is no ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," function in the program, the program will be initialized without any custom actions."),(0,r.kt)("p",null,"And the third most important function is ",(0,r.kt)("inlineCode",{parentName:"p"},"handle_reply()"),". It is called when the program receives a reply to the message that was sent by the program. For example, we can check the reply and perform some actions depending on the reply type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[no_mangle]\nextern "C" fn handle_reply() {\n    // Execute this code during handling reply on the previously sent message\n}\n')),(0,r.kt)("p",null,"There is no need to define the ",(0,r.kt)("inlineCode",{parentName:"p"},"handle_reply()")," function if the program doesn't intend to receive replies. In this case, the program will ignore all incoming replies."),(0,r.kt)("p",null,"The reply message is similar to the ordinary message, but it has some differences:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The reply message is sent to the user or program that has sent the original message. We can't set the destination of the reply message explicitly."),(0,r.kt)("li",{parentName:"ul"},"We can send only one reply message per execution. We get an error if we try to send more than one reply message."),(0,r.kt)("li",{parentName:"ul"},"Even if the program execution is failed (for example, panic is called or the gas limit is exceeded), the reply message will be sent anyway."),(0,r.kt)("li",{parentName:"ul"},"The reply message is processed in ",(0,r.kt)("inlineCode",{parentName:"li"},"handle_reply()")," function instead of ",(0,r.kt)("inlineCode",{parentName:"li"},"handle()")," function for the ordinary message. We have mentioned this above but it is worth to underline it again.")),(0,r.kt)("h2",{id:"api-functions-imported-functions"},"API functions (imported functions)"),(0,r.kt)("p",null,"There are a lot of imported functions that can be used by the Gear smart contract. They are called API functions. These functions are provided by the runtime that executes the Gear smart contract. The most convenient way to use these functions is to use the Gear standard library called ",(0,r.kt)("a",{parentName:"p",href:"https://docs.gear.rs/gstd/"},(0,r.kt)("inlineCode",{parentName:"a"},"gstd")),". It is a set of high-level functions that are implemented on top of the low-level API functions."),(0,r.kt)("p",null,"More details about the Gear standard library can be found in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/developing-contracts/gstd"},"Gear Library")," section."),(0,r.kt)("h2",{id:"basic-stages-of-the-gear-smart-contract-lifecycle"},"Basic stages of the Gear smart contract lifecycle"),(0,r.kt)("p",null,"Let's explore the typical lifecycle of a Gear smart contract. We will use the Rust programming language for the examples, but the same principles are applied to any other language that can be compiled into Wasm."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 1.")," Write the program code."),(0,r.kt)("p",null,"You can find the minimal example in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/getting-started-in-5-minutes"},"Getting Started")," section. It is a simple program that stores the counter, can increment and decrement it, and return the current value of the counter."),(0,r.kt)("p",null,"More advanced examples can be found in the Gear dApps organization on GitHub: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps"},"https://github.com/gear-dapps")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 2.")," Test the program."),(0,r.kt)("p",null,"We recommend using the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.gear.rs/gtest/"},(0,r.kt)("inlineCode",{parentName:"a"},"gtest"))," crate for testing Gear smart contracts. It allows us to write unit tests for the program and run them in the local environment."),(0,r.kt)("p",null,"The more advanced way to test the program is to use the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.gear.rs/gclient/"},(0,r.kt)("inlineCode",{parentName:"a"},"gclient"))," crate that allows you to run the program in the blockchain network. It is useful when you need to test the program in a real environment."),(0,r.kt)("p",null,"You can find more details about testing in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/developing-contracts/testing"},"Program Testing")," section."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 3.")," Compile the program into Wasm."),(0,r.kt)("p",null,"We recommend using the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.gear.rs/gear_wasm_builder/"},(0,r.kt)("inlineCode",{parentName:"a"},"gear-wasm-builder"))," crate in a custom build script ",(0,r.kt)("inlineCode",{parentName:"p"},"build.rs"),"."),(0,r.kt)("p",null,"Add it to the ",(0,r.kt)("inlineCode",{parentName:"p"},"[build-dependencies]")," section in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'[build-dependencies]\ngear-wasm-builder = { git = "https://github.io/gear-tech/gear.git", features = ["wasm-opt"] }\n')),(0,r.kt)("p",null,"And add the following code to the ",(0,r.kt)("inlineCode",{parentName:"p"},"build.rs")," file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"fn main() {\n    gear_wasm_builder::build();\n}\n")),(0,r.kt)("p",null,"You can find built Wasm files in the ",(0,r.kt)("inlineCode",{parentName:"p"},"target/wasm32-unknown-unknown/release")," directory."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 4.")," Deploy the program to the blockchain."),(0,r.kt)("p",null,"Program deployment is a process of storing the program's Wasm code on the blockchain and its initialization. The user pays a fee for the deployment transaction. The program is deployed to the blockchain only once. After that, it can be executed by anyone by sending a message to it."),(0,r.kt)("p",null,"If initialization fails (for example, the program panics in the ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," function), the program is not deployed and the user gets an error."),(0,r.kt)("p",null,"Also, it is important to underline that someone should pay rent for keeping the program in the blockchain after a free period that is equal to 5 million blocks (it is about 2 months for networks with 1 block per second production). It is possible to add funds for rent using the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.gear.rs/pallet_gear/pallet/struct.Pallet.html#method.pay_program_rent"},(0,r.kt)("inlineCode",{parentName:"a"},"pay_program_rent"))," extrinsic (by the user) or with the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.gear.rs/gstd/exec/fn.pay_program_rent.html"},(0,r.kt)("inlineCode",{parentName:"a"},"gstd::exec::pay_program_rent"))," API function (by the program). If the rent is not paid, the program state changes to pause, its persistent memory is removed from the storage, and the program can't be executed. The program can be resumed by uploading its memory pages to the blockchain and paying the rent."),(0,r.kt)("p",null,"You can find more details about program deployment in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/developing-contracts/deploy"},"Upload Program")," section."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 5.")," Execute the program."),(0,r.kt)("p",null,"The program can be executed by sending a message to it. The message can be sent by the user or by another program. The user pays a fee for the message execution. The program can send a reply to the message. The reply is sent to the user or program that has sent the original message."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 6.")," Terminate the program."),(0,r.kt)("p",null,"The program can be terminated by calling the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.gear.rs/gstd/exec/fn.exit.html"},(0,r.kt)("inlineCode",{parentName:"a"},"gstd::exec::exit"))," function. Also, the program is paused if the rent is not paid."),(0,r.kt)("p",null,"The program can't be executed after termination."),(0,r.kt)("h2",{id:"smart-contract-key-features"},"Smart contract key features"),(0,r.kt)("p",null,"Gear smart contracts have a lot of features that make them unique. Let's explore the most important of them."),(0,r.kt)("h3",{id:"state-function"},"State function"),(0,r.kt)("p",null,"Gear smart contracts can store the state in persistent memory. Anyone can read this memory from the blockchain."),(0,r.kt)("p",null,"To make state reading more convenient, Gear smart contracts can define the ",(0,r.kt)("inlineCode",{parentName:"p"},"state()")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[no_mangle]\nextern "C" fn state() {\n    msg::reply(any_encodable_data, 0).expect("Failed to share state");\n}\n')),(0,r.kt)("p",null,"This function is stored in the blockchain in the same Wasm blob with ",(0,r.kt)("inlineCode",{parentName:"p"},"handle()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," functions. But unlike them, it is not executed using extrinsic and doesn't affect the blockchain state. It can be executed for free by any node with a fully synchronized blockchain state. There is a dedicated ",(0,r.kt)("a",{parentName:"p",href:"https://docs.gear.rs/pallet_gear_rpc/trait.GearApiServer.html#tymethod.read_state"},(0,r.kt)("inlineCode",{parentName:"a"},"read_state"))," RPC call for this."),(0,r.kt)("p",null,"The data returned by the ",(0,r.kt)("inlineCode",{parentName:"p"},"state()")," function can be converted to any convenient representation by using a state-conversion program. This is a separate program compiled into Wasm and dedicated to being executed on the off-chain runner. It should contain a set of meta-functions that accept the data returned by the ",(0,r.kt)("inlineCode",{parentName:"p"},"state()")," function and return the data in a convenient format. There is a dedicated ",(0,r.kt)("a",{parentName:"p",href:"https://docs.gear.rs/pallet_gear_rpc/trait.GearApiServer.html#tymethod.read_state_using_wasm"},(0,r.kt)("inlineCode",{parentName:"a"},"read_state_using_wasm"))," RPC call for reading the program state using the state-conversion program."),(0,r.kt)("p",null,"More details about state functions can be found in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/developing-contracts/state"},"State Functions")," section."),(0,r.kt)("h3",{id:"asynchronous-programming"},"Asynchronous programming"),(0,r.kt)("p",null,"In some cases, it is more convenient to express some concepts in an asynchronous programming style. For example, when you need to wait for a reply from another program or wait for a certain time."),(0,r.kt)("p",null,"Under the hood, the ",(0,r.kt)("inlineCode",{parentName:"p"},"async"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"await")," syntax is a kind of syntactic sugar that generates a state machine around ",(0,r.kt)("a",{parentName:"p",href:"https://docs.gear.rs/gstd/exec/fn.wait.html"},(0,r.kt)("inlineCode",{parentName:"a"},"gstd::exec::wait"))," and ",(0,r.kt)("a",{parentName:"p",href:"https://docs.gear.rs/gstd/exec/fn.wake.html"},(0,r.kt)("inlineCode",{parentName:"a"},"gstd::exec::wake"))," functions. The state machine is stored in the program's persistent memory."),(0,r.kt)("p",null,"Note that in case of using async functions, you are to declare the ",(0,r.kt)("inlineCode",{parentName:"p"},"async main()")," function with ",(0,r.kt)("inlineCode",{parentName:"p"},"#[async_main]")," attribute instead of the ",(0,r.kt)("inlineCode",{parentName:"p"},"handle()")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[gstd::async_main]\nasync fn main() {\n    // Async code here\n}\n")),(0,r.kt)("p",null,"The initialization function can also be declared as an async function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[gstd::async_init]\nasync fn init() {\n    // Async init code here\n}\n")),(0,r.kt)("p",null,"You can find more details about asynchronous programming in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/developing-contracts/interactions-between-programs"},"Asynchronous Programming")," section."),(0,r.kt)("h3",{id:"creating-programs-from-programs"},"Creating programs from programs"),(0,r.kt)("p",null,"Both users and programs are actors in terms of the Gear smart contract model. Therefore, any actor can create a new program and deploy it to the blockchain."),(0,r.kt)("p",null,"The only pre-requisite is that the code of the program should be stored in the blockchain. This can be done by using the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.gear.rs/pallet_gear/pallet/struct.Pallet.html#method.upload_code"},(0,r.kt)("inlineCode",{parentName:"a"},"upload_code"))," extrinsic that returns an identifier of the uploaded code. The code can be uploaded only once, then it can be used for creating multiple programs."),(0,r.kt)("p",null,"There are several helper functions for creating programs from programs in the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.gear.rs/gstd/prog/"},(0,r.kt)("inlineCode",{parentName:"a"},"gstd::prog"))," module."),(0,r.kt)("p",null,"More details about creating programs from programs can be found in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/developing-contracts/create"},"Create Program")," section."),(0,r.kt)("h3",{id:"gas-reservation"},"Gas reservation"),(0,r.kt)("p",null,"Gear smart contracts use gas for measuring the complexity of the program execution. The user pays a fee for the gas used by the program. Some part of the gas limit may be reserved during the current execution to be spent later. This gas reserving mechanism can be used to shift the burden of paying for program execution from one user to another. Also, it makes it possible to run some deferred actions using delayed messages described below."),(0,r.kt)("p",null,"You can find more details about gas reservation in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/developing-contracts/gas-reservation"},"Gas Reservation")," section."),(0,r.kt)("h3",{id:"delayed-messages"},"Delayed messages"),(0,r.kt)("p",null,"Gear smart contracts can send messages to other actors not only during the current execution but also after some time. This mechanism can be used to implement deferred actions."),(0,r.kt)("p",null,"Use functions with ",(0,r.kt)("inlineCode",{parentName:"p"},"*_delayed")," suffix from ",(0,r.kt)("a",{parentName:"p",href:"https://docs.gear.rs/gstd/msg/index.html"},(0,r.kt)("inlineCode",{parentName:"a"},"gstd::msg"))," module to send a delayed message to a program or user. The message will be sent after the specified number of blocks."),(0,r.kt)("p",null,"More details about delayed messages can be found in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/developing-contracts/delayed-messages"},"Delayed Messages")," section."),(0,r.kt)("h3",{id:"system-signals"},"System signals"),(0,r.kt)("p",null,"Sometimes the system that executes the program should communicate with it in some manner. For example, the program should be notified when the rent is not paid. This can be done by using system signals."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"handle_signal()")," function should be declared in the program to handle system signals. It is executed when the program receives a system signal."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},' #[no_mangle]\nextern "C" fn handle_signal() {\n    // Handle system signal here\n}\n')),(0,r.kt)("p",null,"You can find more details about system signals in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/developing-contracts/system-signals"},"System Signals")," section."))}m.isMDXComponent=!0}}]);