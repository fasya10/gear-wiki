"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[6130],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=l(n),h=r,m=d["".concat(c,".").concat(h)]||d[h]||u[h]||o;return n?a.createElement(m,s(s({ref:t},p),{},{components:n})):a.createElement(m,s({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[d]="string"==typeof e?e:r,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8348:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));const o={},s="Gear fungible token standard",i={unversionedId:"developing-contracts/token-standards/gft20",id:"developing-contracts/token-standards/gft20",title:"Gear fungible token standard",description:"Contract state:",source:"@site/docs/developing-contracts/token-standards/gft20.md",sourceDirName:"developing-contracts/token-standards",slug:"/developing-contracts/token-standards/gft20",permalink:"/docs/developing-contracts/token-standards/gft20",draft:!1,editUrl:"https://github.com/gear-tech/wiki/edit/master/docs/developing-contracts/token-standards/gft20.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Testing with gclient",permalink:"/docs/developing-contracts/testing-gclient"},next:{title:"Prerequisites",permalink:"/docs/examples/prerequisites"}},c={},l=[{value:"Messages Interface",id:"messages-interface",level:2},{value:"Detailed description",id:"detailed-description",level:2},{value:"Scenarios",id:"scenarios",level:2},{value:"Rationality for using the transaction IDs:",id:"rationality-for-using-the-transaction-ids",level:4}],p={toc:l},d="wrapper";function u(e){let{components:t,...o}=e;return(0,r.kt)(d,(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"gear-fungible-token-standard"},"Gear fungible token standard"),(0,r.kt)("p",null,"Contract state:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"struct Token \n    balances: HashMap<ActorId, u128>,\n    allowances: HashMap<ActorId, HashMap<ActorId, u128>>,\n    nonces: HashMap<ActorId, u64>,\n    account_to_tx_ids: HashMap<ActorId, Vec<TxHash>,\n    tx_ids: HashMap<TxHash, (TokenMessage, TxResult)>,\n    deposits: HashMap<ActorId, u128>,\n}\n")),(0,r.kt)("p",null,"where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"balance"),": a mapping or HashMap from account addresses to ",(0,r.kt)("inlineCode",{parentName:"li"},"u128")," value representing the amount of tokens held by the user at that address;"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"allowances"),": a mapping between an account and another mapping between an authorized spender account and the maximum amount of tokens they are permitted to transfer on behalf of the original account."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"nonces"),": a mapping from account to ",(0,r.kt)("inlineCode",{parentName:"li"},"u32")," value, representing the nonce value for each account. The purpose of using nonces in a smart contract is to prevent replay attacks, which occur when an attacker tries to re-submit a previously executed transaction with the same parameters in an attempt to trick the system into processing it again. By incrementing the nonce value for each new transaction initiated by an account, the system can verify that the transaction is unique and has not been executed before. If the caller specifies an incorrect nonce value (i.e. one that is not equal to the current nonce value for their account), the transaction will be rejected, preventing any potential duplicate transactions."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"account_to_tx_ids"),": a mapping from the account to the transactions executed in the token contract. It is very useful for state consistency, where two parties need to verify that they have the same representation of transactions associated with a specific user. This can provide an added layer of security and confidence in the execution of transactions."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tx_ids"),": a mapping from the transaction hash to the correspong message and its execution result. This allows for easy retrieval of transaction information, such as the result of a particular transaction, using the transaction hash as a key. The ",(0,r.kt)("inlineCode",{parentName:"li"},"TokenMessage")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"TxResult")," structures will be described below."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"deposits"),": a mapping from account to the amount of Vara tokens the account has deposited in the token contract. This deposit serves as collateral for the account to store its transaction history in the contract. To withdraw locked Vara tokens the account has to clear his transaction history. Overall, it is a mechanism for incentivizing users to use the contract's storage efficiently and avoid bloating the contract with unnecessary data.")),(0,r.kt)("h2",{id:"messages-interface"},"Messages Interface"),(0,r.kt)("p",null,"The message the token contract should handle:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"enum TokenMessage {\n    Transfer {\n            nonce: Option<u32>,\n            tx_id: u32,\n            recipient: ActorId,\n            amount: u128,\n    },\n    TransferBatch {\n        nonce: Option<u32>,\n        tx_id: u32,\n        recipients: Vec<ActorId>,\n        amounts: Vec<u128>,\n    },\n    TransferFrom {\n        nonce: Option<u32>,\n        tx_id: u32,\n        sender: ActorId,\n        recipient: ActorId,\n        amount: u128,\n    },\n    TransferFromBatch {\n        nonce: Option<u32>,\n        tx_id: u32,\n        senders: Vec<ActorId>,\n        recipients: Vec<ActorId>,\n        amounts: Vec<u128>,\n    },\n    Approve {\n        nonce: Option<u64>,\n        tx_id: u32,\n        spender: Vec<ActorId>,\n        amount: Vec<u128>,\n    },\n    GetNonce {\n        account: ActorId,\n    },\n    GetTxResult {\n        tx_hash: TxHash,\n    },\n    ClearTxs {\n        account: ActorId,\n    },\n}\n")),(0,r.kt)("p",null,"The contract responds with ",(0,r.kt)("inlineCode",{parentName:"p"},"Result<TokenReply, TokenError>"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"TokenReply")," is a reply in case of successful message execution, and ",(0,r.kt)("inlineCode",{parentName:"p"},"TokenError")," contains information about the error that occurred during message processing."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"enum TokenReply {\n    TokensTransferred,\n    TokenTransferredInBatch {\n        errors: Option<(\n            recipients: Vec<ActorId>,\n            amounts: Vec<u128>,\n            errors: Vec<TokenError>\n        )>,\n    },\n    TokenTransferredFromInBatch {\n        errors: Option<(\n            senders: Vec<ActorId>,\n            recipients: Vec<ActorId>,\n            amounts: Vec<u128>,\n            errors: Vec<TokenError>\n        )>,\n    },\n    TokensApproved,\n    NonceOfAccount {\n        nonce: u32,\n    },\n    TxResult {\n        result: (TokenMessage, TxResult)\n    },\n    TxsCleared,\n}\n")),(0,r.kt)("p",null,"Error that can occur during messages handling:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"enum TokenError {\n    NotAllowedToTransfer,\n    NotEnoughBalance,\n    ZeroAccount,\n}\n")),(0,r.kt)("p",null,"The result of the message handling can be the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"enum TxResult {\n    Success,\n    Error(TokenError),\n    ErrorsInBatches(Vec<Option<TokenError>)\n}\n")),(0,r.kt)("h2",{id:"detailed-description"},"Detailed description"),(0,r.kt)("p",null,"Incoming messages:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Transfer")," message: transfers tokens from the caller's account to the recipient's account.\n",(0,r.kt)("inlineCode",{parentName:"p"},"tx_id")," field is used for transaction identification and to ensure transaction idempotency. The ",(0,r.kt)("inlineCode",{parentName:"p"},"nonce")," field is optional."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"    Transfer {\n        nonce: Option<u32>,\n        tx_id: u32,\n        recipient: ActorId,\n        amount: u128,\n    },\n")),(0,r.kt)("p",{parentName:"li"},"   In case of successful transaction execution, the contract responds with the message:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"    Ok(TokenReply::TokenTransferred)\n")),(0,r.kt)("p",{parentName:"li"},"   In case of an error, the contract responds with ",(0,r.kt)("inlineCode",{parentName:"p"},"Err(TokenError)")," indicating the error that occur during message processing.\nThe Token saves the transaction result to the ",(0,r.kt)("inlineCode",{parentName:"p"},"tx_ids")," field that here can be ",(0,r.kt)("inlineCode",{parentName:"p"},"TxResult::Success")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"TxResult::Error"),".\n")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"TransferBatch")," message: transfers tokens in batches, where the arrays ",(0,r.kt)("inlineCode",{parentName:"p"},"recipients")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"amounts")," are of equal length. This means that the value in ",(0,r.kt)("inlineCode",{parentName:"p"},"amounts[i]")," is transferred to ",(0,r.kt)("inlineCode",{parentName:"p"},"recipients[i]"),".\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"nonce")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"tx_id")," fields apply to the entire batch transfer, not individual transfers within the batch. So if provided, the same nonce and tx_id value should be used for all transfers within the batch."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"```rust \nTransferBatch {\n    nonce: Option<u32>,\n    tx_id: u32,\n    recipients: Vec<ActorId>,\n    amounts: Vec<u128>,\n},\n```\n It is possible that some transfers will succeed and some will fail. In case all transfers are successful, the token will reply with:\n ```rust\n    Ok(TokenReply::TokenTransferredInBatch {\n        errors: None\n    })\n```\nIf any transfer fails, the token will indicate it by responding with \n```rust\n    Ok(TokenReply::TokenTransferredInBatch {\n        errors: Some(\n            recipiens: Vec<ActorId>,\n            amounts: Vec<u128>,\n            errors: Vec<TokenError>,\n        )\n    })\n```\n\nThe Token saves the transaction result to the `tx_ids` field that here can be `TxResult::Success` or `TxResult::ErrorsInBatches`.\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"TransferFrom")," message: transfers the indicated amount from the sender's account to the recipient's account. This message is used to allow a contract to transfer tokens on behalf of a user.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"nonce")," field is optional."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"```rust\nTransferFrom {\n    nonce: Option<u32>,\n    tx_id: u32,\n    sender: ActorId,\n    recipient: ActorId,\n    amount: u128,\n},\n```\n In case of successful transaction execution, the contract responds with the message:\n```rust\n    Ok(TokenReply::TokenTransferred)\n```\nIn case of an error, the contract responds with `Err(TokenError)` indicating the error that occur during message processing.\nThe Token saves the transaction result to the `tx_ids` field that here can be `TxResult::Success` or `TxResult::Error`.\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"TransferFromBatch")," message: it is similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"TransferFrom")," but can transfer tokens in batches, where ",(0,r.kt)("inlineCode",{parentName:"p"},"amounts[i]")," is transferred from ",(0,r.kt)("inlineCode",{parentName:"p"},"sender[i]")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"recipient[i]"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"nonce")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"tx_id")," fields apply to the entire batch transfer, not individual transfers within the batch. So if provided, the same nonce and tx_id value should be used for all transfers within the batch."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"TransferFromBatch {\n    nonce: Option<u32>,\n    tx_id: u32,\n    sender: Vec<ActorId>,\n    recipient: Vec<ActorId>,\n    amount: Vec<u128>,\n},\n")),(0,r.kt)("p",{parentName:"li"},"  It is possible that some transfers will succeed and some will fail. In case all transfers are successful, the token will reply with:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"   Ok(TokenReply::TokenTransferredFromInBatch {\n       errors: None\n   })\n")),(0,r.kt)("p",{parentName:"li"},"  If any transfer fails, the token will indicate it by responding with "),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"    Ok(TokenReply::TokenTransferredFromInBatch {\n        errors: Some(\n            senders: Vec<ActorId>,\n            recipiens: Vec<ActorId>,\n            amounts: Vec<u128>,\n            errors: Vec<TokenError>,\n        )\n    })\n")),(0,r.kt)("p",{parentName:"li"},"  The Token saves the transaction result to the ",(0,r.kt)("inlineCode",{parentName:"p"},"tx_ids")," field that here can be ",(0,r.kt)("inlineCode",{parentName:"p"},"TxResult::Success")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"TxResult::ErrorsInBatches"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Approve")," message: allows the ",(0,r.kt)("inlineCode",{parentName:"p"},"spender")," to withdraw tokens from the ",(0,r.kt)("inlineCode",{parentName:"p"},"sender's")," account, up to the indicated amount. This can be useful in cases where the ",(0,r.kt)("inlineCode",{parentName:"p"},"sender")," wants to authorize another address (the ",(0,r.kt)("inlineCode",{parentName:"p"},"spender"),") to spend a certain amount of tokens from their account, without actually transferring the tokens at that time. The ",(0,r.kt)("inlineCode",{parentName:"p"},"spender")," can later use the ",(0,r.kt)("inlineCode",{parentName:"p"},"transferFrom")," method to withdraw tokens up to the approved amount. This can be particularly useful in scenarios such as decentralized exchanges, where users may want to temporarily authorize the exchange to access their tokens for trading purposes.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"nonce")," field is optional."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"```rust\nApprove {\n    nonce: Option<u64>,\n    tx_id: u32,\n    spender: Vec<ActorId>,\n    amount: Vec<u128>,\n},\n```\nIn case of successful transaction execution, the contract responds with the message:\n```rust\n    Ok(TokenReply::TokensApproved)\n```\nIn case of an error, the contract responds with `Err(TokenError)` indicating the error that occur during message processing.\nThe Token saves the transaction result to the `tx_ids` field that here can be `TxResult::Success` or `TxResult::Error`.\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"GetNonce")," message: a request for the ",(0,r.kt)("inlineCode",{parentName:"p"},"nonce")," value of the specified ",(0,r.kt)("inlineCode",{parentName:"p"},"account"),"."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"GetNonce {\n    account: ActorId,\n},\n")),(0,r.kt)("p",{parentName:"li"},"  Sends a ",(0,r.kt)("inlineCode",{parentName:"p"},"reply")," with the current nonce of the account. If the account has not yet made a transaction in the token contract, the nonce will be 0."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"Ok(TokenReply::NonceOfAccount {\n    nonce,\n})\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"GetTxResult")," message: a request for the transaction result."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"GetTxResult {\n    tx_hash: TxHash,\n},\n")),(0,r.kt)("p",{parentName:"li"},"  returns the message that was being processed and the result of the message processing:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"Ok(TokenReply::TxResult {\n    result: (TokenMessage, TxResult)\n})\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ClearTxs")," message: clears the transaction history of the specified account and withdraws his deposit."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"   ClearTxs {\n       account: ActorId,\n   },\n")))),(0,r.kt)("h2",{id:"scenarios"},"Scenarios"),(0,r.kt)("p",null,"Let's consider a scenario where a user wants to send tokens to a ",(0,r.kt)("inlineCode",{parentName:"p"},"Swap")," contract in order to exchange them later. This can be done using the combination of messages ",(0,r.kt)("inlineCode",{parentName:"p"},"TransferFrom")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Approve"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To transfer tokens to a swap contract using ",(0,r.kt)("inlineCode",{parentName:"li"},"transferFrom")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"approve"),", the user first needs to approve the swap contract to withdraw a certain amount of tokens from its account. This can be done by sending the a",(0,r.kt)("inlineCode",{parentName:"li"},"Approve")," message with the ",(0,r.kt)("inlineCode",{parentName:"li"},"spender")," parameter set to the address of the swap contract and the amount parameter set to the desired amount of tokens.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"After the approval, the user sends a ",(0,r.kt)("inlineCode",{parentName:"li"},"Deposit")," message to the ",(0,r.kt)("inlineCode",{parentName:"li"},"Swap")," contract, which then sends a ",(0,r.kt)("inlineCode",{parentName:"li"},"TransferFrom")," message to the token contract on behalf of the user's account. The token contract checks if the ",(0,r.kt)("inlineCode",{parentName:"li"},"Swap")," contract is approved to transfer the user's tokens and if so, transfers the tokens to the ",(0,r.kt)("inlineCode",{parentName:"li"},"Swap")," contract and sends a success reply back to the ",(0,r.kt)("inlineCode",{parentName:"li"},"Swap")," contract. The Swap contract records that the user has transferred tokens, sends a reply to the user, and completes the transaction.")),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(7841).Z,width:"3357",height:"2166"})),(0,r.kt)("h4",{id:"rationality-for-using-the-transaction-ids"},"Rationality for using the transaction IDs:"),(0,r.kt)("p",null,"Let's consider the following scenario:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The user successfully approved tokens for the ",(0,r.kt)("inlineCode",{parentName:"li"},"Swap")," contract."),(0,r.kt)("li",{parentName:"ol"},"The user sent a message to the ",(0,r.kt)("inlineCode",{parentName:"li"},"Swap")," contract, which in turn sent a message to the ",(0,r.kt)("inlineCode",{parentName:"li"},"Token")," contract."),(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"Token")," contract checked that it could transfer tokens to the ",(0,r.kt)("inlineCode",{parentName:"li"},"Swap")," contract and made the transfer."),(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"Token")," contract sent a reply to the ",(0,r.kt)("inlineCode",{parentName:"li"},"Swap")," contract about the successful transfer, but at this point, the gas ran out. It turns out that tokens were transferred to the ",(0,r.kt)("inlineCode",{parentName:"li"},"Swap")," contract, but the ",(0,r.kt)("inlineCode",{parentName:"li"},"Swap")," contract did not record it, resulting in an inconsistency in the states.")),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(8409).Z,width:"3357",height:"2166"})),(0,r.kt)("p",null,"Using transaction IDs can achieve transaction idempotency in the token contract. The scenario can be as follows:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The user sends a deposit message to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Swap")," contract.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Swap")," contract records the start of the token transfer with a specific ",(0,r.kt)("inlineCode",{parentName:"p"},"tx_id")," and sends a message to transfer the tokens with the specified ",(0,r.kt)("inlineCode",{parentName:"p"},"tx_id"),"."),(0,r.kt)("p",{parentName:"li"},"If gas runs out somewhere after recording the start of the transfer by the ",(0,r.kt)("inlineCode",{parentName:"p"},"Swap")," contract, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Swap")," contract will show that the token transfer started but was not completed.\nThe user can send a request to complete the transaction, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"Swap")," contract will send the same message to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Token")," contract with the same ",(0,r.kt)("inlineCode",{parentName:"p"},"tx_id"),". If the ",(0,r.kt)("inlineCode",{parentName:"p"},"Token")," contract has already executed this message with the specified ",(0,r.kt)("inlineCode",{parentName:"p"},"tx_id"),", it will not execute it again, but will only send a reply with the transaction result.\nThus, the ",(0,r.kt)("inlineCode",{parentName:"p"},"tx_id")," can prevent transaction duplication and enables to bring the states of contracts into agreement in case of network failure."))),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(1924).Z,width:"3357",height:"2166"})))}u.isMDXComponent=!0},7841:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/gft2-std-scenario1-6e9cb7f0f1ef6c32e401447b7f214c04.png"},8409:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/gft2-std-scenario2-928556364318a9cf8e8a78ade30d1c96.png"},1924:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/gft2-std-scenario3-dc1a1bda74a3b5e2388d624f0e62978d.png"}}]);