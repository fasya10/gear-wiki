"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[2175],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=r,f=p["".concat(l,".").concat(m)]||p[m]||u[m]||o;return n?a.createElement(f,i(i({ref:t},d),{},{components:n})):a.createElement(f,i({ref:t},d))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8533:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_label:"Dynamic NFT",sidebar_position:5},i="Gear Dynamic Non-Fungible Token",s={unversionedId:"examples/dynamic-nft",id:"examples/dynamic-nft",title:"Gear Dynamic Non-Fungible Token",description:"Introduction",source:"@site/docs/examples/dynamic-nft.md",sourceDirName:"examples",slug:"/examples/dynamic-nft",permalink:"/zh-cn/docs/examples/dynamic-nft",draft:!1,editUrl:"https://github.com/gear-tech/wiki/edit/master/docs/examples/dynamic-nft.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_label:"Dynamic NFT",sidebar_position:5},sidebar:"docs",previous:{title:"gNFT (ERC-721)",permalink:"/zh-cn/docs/examples/gnft-721"},next:{title:"gMT (ERC-1155)",permalink:"/zh-cn/docs/examples/gmt-1155"}},l={},c=[{value:"Introduction",id:"introduction",level:3},{value:"Motivation",id:"motivation",level:3},{value:"Details",id:"details",level:3},{value:"Examples",id:"examples",level:2},{value:"Conclusion",id:"conclusion",level:2}],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"gear-dynamic-non-fungible-token"},"Gear Dynamic Non-Fungible Token"),(0,r.kt)("h3",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"This is an extension of standard ",(0,r.kt)("a",{parentName:"p",href:"./gnft-721"},"Non-Fungible token"),". It proposes an additional dynamic part that can change or evolve over time. The source code of the Gear NFT smart contract example is available on ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/dynamic-nft"},"GitHub"),"."),(0,r.kt)("h3",{id:"motivation"},"Motivation"),(0,r.kt)("p",null,"Unlike traditional NFTs that represent a static digital asset, dynamic NFTs can have various attributes, properties, or behaviors that can be modified based on certain conditions or user interactions. These changes can be triggered by external factors such as market demand, user preferences, or even real-world events. For example, a dynamic NFT representing a digital artwork may change its appearance or color scheme based on the time of day or weather conditions."),(0,r.kt)("p",null,"This example demonstrates Gear Protocol's unique features enabling the new user experience for totally on-chain, truly decentralized applications that do not require centralized components. ",(0,r.kt)("a",{parentName:"p",href:"/zh-cn/docs/developing-contracts/delayed-messages"},"Delayed messages")," allows the contract to wake itself after a specified period of time. It is acheived via ",(0,r.kt)("a",{parentName:"p",href:"/zh-cn/docs/developing-contracts/gas-reservation"},"gas reservation")," feature, which allows for the creation of gas pools that can be used by programs for further execution."),(0,r.kt)("h3",{id:"details"},"Details"),(0,r.kt)("p",null,"The default implementation of the NFT contract is provided in the gear library: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/gear-lib/tree/master/lib/src/non_fungible_token"},"gear-lib/non_fungible_token"),"."),(0,r.kt)("p",null,"To use the default implementation you should include the packages into your ",(0,r.kt)("em",{parentName:"p"},"Cargo.toml")," file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'gear-lib = { git = "https://github.com/gear-dapps/gear-lib.git" }\ngear-lib-derive = { git = "https://github.com/gear-dapps/gear-lib.git" }\nhashbrown = "0.13"\n')),(0,r.kt)("p",null,"Dynamic NFT contains regular NFT (gnft-721) and additional field  ",(0,r.kt)("inlineCode",{parentName:"p"},"dynamic_data"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use hashbrown::HashMap;\n\n#[derive(Debug, Default, NFTStateKeeper, NFTCore, NFTMetaState)]\npub struct DynamicNft {\n    #[NFTStateField]\n    pub token: NFTState,\n    pub token_id: TokenId,\n    pub owner: ActorId,\n    pub transactions: HashMap<H256, NFTEvent>,\n    pub dynamic_data: Vec<u8>,\n}\n")),(0,r.kt)("p",null,"In all other cases, everything also corresponds to the usual ",(0,r.kt)("a",{parentName:"p",href:"./gnft-721"},"non-fungible-token")," contract, except additional specific actions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, Encode, Decode, TypeInfo)]\npub enum NFTAction {\n    // ... like a usual NFT contract\n    UpdateDynamicData {\n        transaction_id: u64,\n        data: Vec<u8>,\n    },\n}\n")),(0,r.kt)("p",null,"And features specific events:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Clone, Debug, Encode, Decode, TypeInfo)]\npub enum NFTEvent {\n    Updated {\n        data_hash: H256,\n    },\n}\n")),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("p",null,"For an example, look at this ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/auto-changed-nft"},"Auto-changed NFT")," contract. This is a modified dynamic contract in which own dynamic data changes over time periods. We slightly changed the logic of the dynamic nft  contract to suit our needs."),(0,r.kt)("p",null,"First, let's change the name of the contract and add a new field ",(0,r.kt)("inlineCode",{parentName:"p"},"rest_update_periods")," in which we store the rest update periods (in our example, we need 2 updates):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct AutoChangedNft {\n    #[NFTStateField]\n    pub token: NFTState,\n    pub token_id: TokenId,\n    pub owner: ActorId,\n    pub transactions: HashMap<H256, NFTEvent>,\n    pub dynamic_data: Vec<u8>,\n    pub rest_update_periods: u32,\n}\n")),(0,r.kt)("p",null,"At initializing the contract, we send a deferred message that will change the dynamic data of the contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[no_mangle]\nunsafe extern "C" fn init() {\n    let config: InitNFT = msg::load().expect("Unable to decode InitNFT");\n    if config.royalties.is_some() {\n        config.royalties.as_ref().expect("Unable to g").validate();\n    }\n    let nft = AutoChangedNft {\n        token: NFTState {\n            name: config.name,\n            symbol: config.symbol,\n            base_uri: config.base_uri,\n            royalties: config.royalties,\n            ..Default::default()\n        },\n        owner: msg::source(),\n        rest_update_periods: 2, // for example - two updates\n        ..Default::default()\n    };\n\n    let periods = nft.rest_update_periods;\n    CONTRACT = Some(nft);\n\n    let data = format!("Rest Update Periods: {}", periods)\n        .as_bytes()\n        .to_vec();\n\n    let payload = NFTAction::UpdateDynamicData {\n        transaction_id: 1,\n        data,\n    };\n    msg::send_delayed(exec::program_id(), payload, 0, DELAY).expect("Cant send delayed msg");\n}\n')),(0,r.kt)("p",null,"Next we will change the ",(0,r.kt)("inlineCode",{parentName:"p"},"handle()")," function, we will add the business logic we need there:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'unsafe extern "C" fn handle() {\n    /// ...\n    NFTAction::UpdateDynamicData {\n            transaction_id,\n            data,\n        } => {\n            let payload = nft.process_transaction(transaction_id, |nft| {\n                let data_hash = H256::from(sp_core_hashing::blake2_256(&data));\n                if nft.rest_update_periods > 0 {\n                    nft.dynamic_data = data;\n                    nft.rest_update_periods -= 1;\n                    let periods = nft.rest_update_periods;\n                    let data = format!("Rest Update Periods: {}", periods)\n                        .as_bytes()\n                        .to_vec();\n                    let payload = NFTAction::UpdateDynamicData {\n                        transaction_id: transaction_id + 1,\n                        data,\n                    };\n                    msg::send_delayed(exec::program_id(), payload, 0, DELAY)\n                        .expect("Can\'t send delayed");\n                } else {\n                    nft.dynamic_data = format!("Expired").as_bytes().to_vec();\n                }\n                NFTEvent::Updated { data_hash }\n            });\n            msg::reply(payload, 0).expect("Error during replying with `NFTEvent::Updated`");\n        }\n\n')),(0,r.kt)("p",null,"All is ready. Then there was a need to check that it works in tests:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[test]\nfn auto_change_success() {\n    let sys = System::new();\n    init_nft(&sys);\n    let nft = sys.get_program(1);\n    let transaction_id: u64 = 0;\n    assert!(!mint(&nft, transaction_id, USERS[0]).main_failed());\n\n    let state: IoNFT = nft.read_state().unwrap();\n    let expected_dynamic_data: Vec<u8> = vec![];\n    assert_eq!(expected_dynamic_data, state.dynamic_data);\n    const DELAY: u32 = 5;\n\n    sys.spend_blocks(DELAY);\n    let state: IoNFT = nft.read_state().unwrap();\n    let expected_dynamic_data = format!("Rest Update Periods: 2").as_bytes().to_vec();\n    assert_eq!(expected_dynamic_data, state.dynamic_data);\n\n    sys.spend_blocks(DELAY);\n    let state: IoNFT = nft.read_state().unwrap();\n    let expected_dynamic_data = format!("Rest Update Periods: 1").as_bytes().to_vec();\n    assert_eq!(expected_dynamic_data, state.dynamic_data);\n\n    sys.spend_blocks(DELAY);\n    let state: IoNFT = nft.read_state().unwrap();\n    let expected_dynamic_data = format!("Expired").as_bytes().to_vec();\n    assert_eq!(expected_dynamic_data, state.dynamic_data);\n}\n')),(0,r.kt)("p",null,"Similarly, you can implement other logic, for example, periodically request data from the Oracle."),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"Gear provides a reusable ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/gear-lib/tree/master/lib/src/non_fungible_token"},"library")," with core functionality for the gNFT-4907 protocol. By using object composition, the library can be utilized within a custom NFT contract implementation in order to minimize duplication of community available code."),(0,r.kt)("p",null,"A source code of the Gear NFT smart contract example based on ",(0,r.kt)("inlineCode",{parentName:"p"},"gear-lib")," is available on GitHub: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/dynamic-nft"},"gear-dapps/non-fungible-token"),"."),(0,r.kt)("p",null,"See also an example of the smart contract testing implementation based on ",(0,r.kt)("inlineCode",{parentName:"p"},"gtest"),": ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/dynamic-nft/tree/master/tests"},"gear-dapps/non-fungible-token/tests"),"."),(0,r.kt)("p",null,"For more details about testing smart contracts written on Gear, refer to this article: ",(0,r.kt)("a",{parentName:"p",href:"/docs/developing-contracts/testing"},"Program Testing"),"."))}u.isMDXComponent=!0}}]);